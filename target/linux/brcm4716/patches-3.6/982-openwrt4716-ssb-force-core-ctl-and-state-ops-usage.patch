From: George Kashperko <george@znau.edu.ua>

Major differences between AI/SB from drivers' perespective is control
and state flags handling. These long term used to be TMSLOW/TMSHIGH ones
and in order to be handled transparently should be masked under some
indirect access handlers. This patch forces use of ssb_core_ctl_flags
and ssb_core_state_flags introduced early. TMSLOW/TMSHIGH defines outside
ssb code (b43, ssb gige and ohci drivers) were renamed to reflect actual
meaning, flags' definitions moved to low two bytes. Common TMSLOW/TMSHIGH
defines moved to ssb_private.h in order to limit their use by internal
SB-specic code only.
Signed-off-by: George Kashperko <george@znau.edu.ua>
---
 drivers/net/ethernet/broadcom/b44.c        |    2 
 drivers/net/wireless/b43/b43.h             |   32 +++++-----
 drivers/net/wireless/b43/dma.c             |    6 -
 drivers/net/wireless/b43/main.c            |   59 +++++++------------
 drivers/net/wireless/b43/phy_common.c      |    8 --
 drivers/net/wireless/b43legacy/b43legacy.h |   20 +++---
 drivers/net/wireless/b43legacy/main.c      |   47 +++++----------
 drivers/net/wireless/b43legacy/phy.c       |    2 
 drivers/ssb/driver_gige.c                  |   18 ++---
 drivers/ssb/main.c                         |   17 ++++-
 drivers/ssb/ssb_private.h                  |   22 +++++++
 drivers/usb/host/ssb-hcd.c                 |    4 -
 include/linux/ssb/ssb.h                    |    4 -
 include/linux/ssb/ssb_driver_gige.h        |   12 +--
 include/linux/ssb/ssb_regs.h               |   41 +++++++------
 15 files changed, 147 insertions(+), 147 deletions(-)
--- linux-3.6.8.orig/drivers/net/ethernet/broadcom/b44.c	2012-12-08 02:32:27.000000000 +0200
+++ linux-3.6.8/drivers/net/ethernet/broadcom/b44.c	2012-12-08 02:54:34.495374389 +0200
@@ -1597,7 +1597,7 @@ static void b44_setup_wol_pci(struct b44
 	u16 val;
 
 	if (bp->sdev->bus->bustype != SSB_BUSTYPE_SSB) {
-		bw32(bp, SSB_TMSLOW, br32(bp, SSB_TMSLOW) | SSB_TMSLOW_PE);
+		ssb_core_ctl_flags(bp->sdev, ~0, SSB_CORECTL_PE);
 		pci_read_config_word(bp->sdev->bus->host_pci, SSB_PMCSR, &val);
 		pci_write_config_word(bp->sdev->bus->host_pci, SSB_PMCSR, val | SSB_PE);
 	}
--- linux-3.6.8.orig/drivers/net/wireless/b43/b43.h	2012-11-26 22:15:45.000000000 +0200
+++ linux-3.6.8/drivers/net/wireless/b43/b43.h	2012-12-08 02:54:34.495374389 +0200
@@ -485,22 +485,22 @@ enum {
 #define B43_BCMA_IOST_FASTCLKA		0x00000004	/* Fast Clock Available */
 #define B43_BCMA_IOST_DUALB_PHY		0x00000008	/* Dualband phy */
 
-/* 802.11 core specific TM State Low (SSB_TMSLOW) flags */
-#define B43_TMSLOW_GMODE		0x20000000	/* G Mode Enable */
-#define B43_TMSLOW_PHY_BANDWIDTH	0x00C00000	/* PHY band width and clock speed mask (N-PHY only) */
-#define  B43_TMSLOW_PHY_BANDWIDTH_10MHZ	0x00000000	/* 10 MHz bandwidth, 40 MHz PHY */
-#define  B43_TMSLOW_PHY_BANDWIDTH_20MHZ	0x00400000	/* 20 MHz bandwidth, 80 MHz PHY */
-#define  B43_TMSLOW_PHY_BANDWIDTH_40MHZ	0x00800000	/* 40 MHz bandwidth, 160 MHz PHY */
-#define B43_TMSLOW_PLLREFSEL		0x00200000	/* PLL Frequency Reference Select (rev >= 5) */
-#define B43_TMSLOW_MACPHYCLKEN		0x00100000	/* MAC PHY Clock Control Enable (rev >= 5) */
-#define B43_TMSLOW_PHYRESET		0x00080000	/* PHY Reset */
-#define B43_TMSLOW_PHYCLKEN		0x00040000	/* PHY Clock Enable */
-
-/* 802.11 core specific TM State High (SSB_TMSHIGH) flags */
-#define B43_TMSHIGH_DUALBAND_PHY	0x00080000	/* Dualband PHY available */
-#define B43_TMSHIGH_FCLOCK		0x00040000	/* Fast Clock Available (rev >= 5) */
-#define B43_TMSHIGH_HAVE_5GHZ_PHY	0x00020000	/* 5 GHz PHY available (rev >= 5) */
-#define B43_TMSHIGH_HAVE_2GHZ_PHY	0x00010000	/* 2.4 GHz PHY available (rev >= 5) */
+/* 802.11 core specific Control (SSB_CORECTL) flags */
+#define B43_CORECTL_GMODE		0x20000000	/* G Mode Enable */
+#define B43_CORECTL_PHY_BANDWIDTH	0x00C00000	/* PHY band width and clock speed mask (N-PHY only) */
+#define  B43_CORECTL_PHY_BANDWIDTH_10MHZ	0x00000000	/* 10 MHz bandwidth, 40 MHz PHY */
+#define  B43_CORECTL_PHY_BANDWIDTH_20MHZ	0x00400000	/* 20 MHz bandwidth, 80 MHz PHY */
+#define  B43_CORECTL_PHY_BANDWIDTH_40MHZ	0x00800000	/* 40 MHz bandwidth, 160 MHz PHY */
+#define B43_CORECTL_PLLREFSEL		0x00200000	/* PLL Frequency Reference Select (rev >= 5) */
+#define B43_CORECTL_MACPHYCLKEN		0x00100000	/* MAC PHY Clock Control Enable (rev >= 5) */
+#define B43_CORECTL_PHYRESET		0x00080000	/* PHY Reset */
+#define B43_CORECTL_PHYCLKEN		0x00040000	/* PHY Clock Enable */
+
+/* 802.11 core specific State (SSB_CORESTAT) flags */
+#define B43_CORESTAT_DUALBAND_PHY	0x00080000	/* Dualband PHY available */
+#define B43_CORESTAT_FCLOCK		0x00040000	/* Fast Clock Available (rev >= 5) */
+#define B43_CORESTAT_HAVE_5GHZ_PHY	0x00020000	/* 5 GHz PHY available (rev >= 5) */
+#define B43_CORESTAT_HAVE_2GHZ_PHY	0x00010000	/* 2.4 GHz PHY available (rev >= 5) */
 
 /* Generic-Interrupt reasons. */
 #define B43_IRQ_MAC_SUSPENDED		0x00000001
--- linux-3.6.8.orig/drivers/net/wireless/b43/dma.c	2012-11-26 22:15:45.000000000 +0200
+++ linux-3.6.8/drivers/net/wireless/b43/dma.c	2012-12-08 02:54:34.496374389 +0200
@@ -827,8 +827,8 @@ static u64 supported_dma_mask(struct b43
 #endif
 #ifdef CONFIG_B43_SSB
 	case B43_BUS_SSB:
-		tmp = ssb_read32(dev->dev->sdev, SSB_TMSHIGH);
-		if (tmp & SSB_TMSHIGH_DMA64)
+		tmp = ssb_core_state_flags(dev->dev->sdev);
+		if (tmp & SSB_CORESTAT_DMA64)
 			return DMA_BIT_MASK(64);
 		break;
 #endif
@@ -1110,7 +1110,7 @@ static bool b43_dma_translation_in_low_w
 	if (dev->dev->bus_type == B43_BUS_SSB &&
 	    dev->dev->sdev->bus->bustype == SSB_BUSTYPE_PCI &&
 	    !(pci_is_pcie(dev->dev->sdev->bus->host_pci) &&
-	      ssb_read32(dev->dev->sdev, SSB_TMSHIGH) & SSB_TMSHIGH_DMA64))
+	      ssb_core_state_flags(dev->dev->sdev) & SSB_CORESTAT_DMA64))
 			return 1;
 #endif
 	return 0;
--- linux-3.6.8.orig/drivers/net/wireless/b43/main.c	2012-12-08 02:31:44.000000000 +0200
+++ linux-3.6.8/drivers/net/wireless/b43/main.c	2012-12-08 02:54:34.497374389 +0200
@@ -1199,28 +1199,22 @@ static void b43_bcma_wireless_core_reset
 static void b43_ssb_wireless_core_reset(struct b43_wldev *dev, bool gmode)
 {
 	struct ssb_device *sdev = dev->dev->sdev;
-	u32 tmslow;
 	u32 flags = 0;
 
 	if (gmode)
-		flags |= B43_TMSLOW_GMODE;
-	flags |= B43_TMSLOW_PHYCLKEN;
-	flags |= B43_TMSLOW_PHYRESET;
+		flags |= B43_CORECTL_GMODE;
+	flags |= B43_CORECTL_PHYCLKEN;
+	flags |= B43_CORECTL_PHYRESET;
 	if (dev->phy.type == B43_PHYTYPE_N)
-		flags |= B43_TMSLOW_PHY_BANDWIDTH_20MHZ; /* Make 20 MHz def */
+		flags |= B43_CORECTL_PHY_BANDWIDTH_20MHZ; /* Make 20 MHz def */
 	b43_device_enable(dev, flags);
 	msleep(2);		/* Wait for the PLL to turn on. */
 
 	/* Now take the PHY out of Reset again */
-	tmslow = ssb_read32(sdev, SSB_TMSLOW);
-	tmslow |= SSB_TMSLOW_FGC;
-	tmslow &= ~B43_TMSLOW_PHYRESET;
-	ssb_write32(sdev, SSB_TMSLOW, tmslow);
-	ssb_read32(sdev, SSB_TMSLOW);	/* flush */
+	ssb_core_ctl_flags(dev->dev->sdev, ~B43_CORECTL_PHYRESET,
+			   SSB_CORECTL_FGC);
 	msleep(1);
-	tmslow &= ~SSB_TMSLOW_FGC;
-	ssb_write32(sdev, SSB_TMSLOW, tmslow);
-	ssb_read32(sdev, SSB_TMSLOW);	/* flush */
+	ssb_core_ctl_flags(dev->dev->sdev, ~SSB_CORECTL_FGC, 0);
 	msleep(1);
 }
 
@@ -2183,7 +2177,6 @@ static int b43_try_request_fw(struct b43
 	struct b43_firmware *fw = &ctx->dev->fw;
 	const u8 rev = ctx->dev->dev->core_rev;
 	const char *filename;
-	u32 tmshigh;
 	int err;
 
 	/* Files for HT and LCN were found by trying one by one */
@@ -2247,8 +2240,8 @@ static int b43_try_request_fw(struct b43
 	switch (dev->phy.type) {
 	case B43_PHYTYPE_A:
 		if ((rev >= 5) && (rev <= 10)) {
-			tmshigh = ssb_read32(dev->dev->sdev, SSB_TMSHIGH);
-			if (tmshigh & B43_TMSHIGH_HAVE_2GHZ_PHY)
+			u32 state = ssb_core_state_flags(dev->dev->sdev);
+			if (state & B43_CORESTAT_HAVE_2GHZ_PHY)
 				filename = "a0g1initvals5";
 			else
 				filename = "a0g0initvals5";
@@ -2304,8 +2297,8 @@ static int b43_try_request_fw(struct b43
 	switch (dev->phy.type) {
 	case B43_PHYTYPE_A:
 		if ((rev >= 5) && (rev <= 10)) {
-			tmshigh = ssb_read32(dev->dev->sdev, SSB_TMSHIGH);
-			if (tmshigh & B43_TMSHIGH_HAVE_2GHZ_PHY)
+			u32 state = ssb_core_state_flags(dev->dev->sdev);
+			if (state & B43_CORESTAT_HAVE_2GHZ_PHY)
 				filename = "a0g1bsinitvals5";
 			else
 				filename = "a0g0bsinitvals5";
@@ -2868,12 +2861,8 @@ void b43_mac_phy_clock_set(struct b43_wl
 #endif
 #ifdef CONFIG_B43_SSB
 	case B43_BUS_SSB:
-		tmp = ssb_read32(dev->dev->sdev, SSB_TMSLOW);
-		if (on)
-			tmp |= B43_TMSLOW_MACPHYCLKEN;
-		else
-			tmp &= ~B43_TMSLOW_MACPHYCLKEN;
-		ssb_write32(dev->dev->sdev, SSB_TMSLOW, tmp);
+		ssb_core_ctl_flags(dev->dev->sdev, ~B43_CORECTL_MACPHYCLKEN,
+				   on ? B43_CORECTL_MACPHYCLKEN : 0);
 		break;
 #endif
 	}
@@ -3665,17 +3654,15 @@ static void b43_put_phy_into_reset(struc
 #endif
 #ifdef CONFIG_B43_SSB
 	case B43_BUS_SSB:
-		tmp = ssb_read32(dev->dev->sdev, SSB_TMSLOW);
-		tmp &= ~B43_TMSLOW_GMODE;
-		tmp |= B43_TMSLOW_PHYRESET;
-		tmp |= SSB_TMSLOW_FGC;
-		ssb_write32(dev->dev->sdev, SSB_TMSLOW, tmp);
+		ssb_core_ctl_flags(dev->dev->sdev, ~(B43_CORECTL_GMODE |
+						     B43_CORECTL_PHYRESET |
+						     SSB_CORECTL_FGC),
+				   B43_CORECTL_PHYRESET | SSB_CORECTL_FGC);
 		msleep(1);
 
-		tmp = ssb_read32(dev->dev->sdev, SSB_TMSLOW);
-		tmp &= ~SSB_TMSLOW_FGC;
-		tmp |= B43_TMSLOW_PHYRESET;
-		ssb_write32(dev->dev->sdev, SSB_TMSLOW, tmp);
+		ssb_core_ctl_flags(dev->dev->sdev, ~(SSB_CORECTL_FGC |
+						     B43_CORECTL_PHYRESET),
+				   B43_CORECTL_PHYRESET);
 		msleep(1);
 
 		break;
@@ -5095,9 +5082,9 @@ static int b43_wireless_core_attach(stru
 #ifdef CONFIG_B43_SSB
 	case B43_BUS_SSB:
 		if (dev->dev->core_rev >= 5) {
-			tmp = ssb_read32(dev->dev->sdev, SSB_TMSHIGH);
-			have_2ghz_phy = !!(tmp & B43_TMSHIGH_HAVE_2GHZ_PHY);
-			have_5ghz_phy = !!(tmp & B43_TMSHIGH_HAVE_5GHZ_PHY);
+			tmp = ssb_core_state_flags(dev->dev->sdev);
+			have_2ghz_phy = !!(state & B43_CORESTAT_HAVE_2GHZ_PHY);
+			have_5ghz_phy = !!(state & B43_CORESTAT_HAVE_5GHZ_PHY);
 		} else
 			B43_WARN_ON(1);
 		break;
--- linux-3.6.8.orig/drivers/net/wireless/b43/phy_common.c	2012-11-26 22:15:45.000000000 +0200
+++ linux-3.6.8/drivers/net/wireless/b43/phy_common.c	2012-12-08 02:54:34.498374389 +0200
@@ -469,12 +469,8 @@ void b43_phy_force_clock(struct b43_wlde
 #endif
 #ifdef CONFIG_B43_SSB
 	case B43_BUS_SSB:
-		tmp = ssb_read32(dev->dev->sdev, SSB_TMSLOW);
-		if (force)
-			tmp |= SSB_TMSLOW_FGC;
-		else
-			tmp &= ~SSB_TMSLOW_FGC;
-		ssb_write32(dev->dev->sdev, SSB_TMSLOW, tmp);
+		ssb_core_ctl_flags(dev->dev->sdev, ~SSB_CORECTL_FGC,
+				   force ? SSB_CORECTL_FGC : 0);
 		break;
 #endif
 	}
--- linux-3.6.8.orig/drivers/net/wireless/b43legacy/b43legacy.h	2012-11-26 22:15:45.000000000 +0200
+++ linux-3.6.8/drivers/net/wireless/b43legacy/b43legacy.h	2012-12-08 02:54:34.498374389 +0200
@@ -213,16 +213,16 @@
 #define B43legacy_MACCMD_CCA		0x00000008 /* Clear channel assessment */
 #define B43legacy_MACCMD_BGNOISE	0x00000010 /* Background noise */
 
-/* 802.11 core specific TM State Low flags */
-#define B43legacy_TMSLOW_GMODE		0x20000000 /* G Mode Enable */
-#define B43legacy_TMSLOW_PLLREFSEL	0x00200000 /* PLL Freq Ref Select */
-#define B43legacy_TMSLOW_MACPHYCLKEN	0x00100000 /* MAC PHY Clock Ctrl Enbl */
-#define B43legacy_TMSLOW_PHYRESET	0x00080000 /* PHY Reset */
-#define B43legacy_TMSLOW_PHYCLKEN	0x00040000 /* PHY Clock Enable */
-
-/* 802.11 core specific TM State High flags */
-#define B43legacy_TMSHIGH_FCLOCK	0x00040000 /* Fast Clock Available */
-#define B43legacy_TMSHIGH_GPHY		0x00010000 /* G-PHY avail (rev >= 5) */
+/* 802.11 core specific control flags */
+#define B43legacy_CORECTL_GMODE		0x2000 /* G Mode Enable */
+#define B43legacy_CORECTL_PLLREFSEL	0x0020 /* PLL Freq Ref Select */
+#define B43legacy_CORECTL_MACPHYCLKEN	0x0010 /* MAC PHY Clock Ctrl Enbl */
+#define B43legacy_CORECTL_PHYRESET	0x0008 /* PHY Reset */
+#define B43legacy_CORECTL_PHYCLKEN	0x0004 /* PHY Clock Enable */
+
+/* 802.11 core specific state flags */
+#define B43legacy_CORESTAT_FCLOCK	0x0004 /* Fast Clock Available */
+#define B43legacy_CORESTAT_GPHY		0x0001 /* G-PHY avail (rev >= 5) */
 
 #define B43legacy_UCODEFLAG_AUTODIV       0x0001
 
--- linux-3.6.8.orig/drivers/net/wireless/b43legacy/main.c	2012-11-26 22:15:45.000000000 +0200
+++ linux-3.6.8/drivers/net/wireless/b43legacy/main.c	2012-12-08 02:54:34.499374389 +0200
@@ -695,24 +695,18 @@ static void b43legacy_switch_analog(stru
 
 void b43legacy_wireless_core_reset(struct b43legacy_wldev *dev, u32 flags)
 {
-	u32 tmslow;
 	u32 macctl;
 
-	flags |= B43legacy_TMSLOW_PHYCLKEN;
-	flags |= B43legacy_TMSLOW_PHYRESET;
+	flags |= B43legacy_CORECTL_PHYCLKEN;
+	flags |= B43legacy_CORECTL_PHYRESET;
 	ssb_device_enable(dev->dev, flags);
 	msleep(2); /* Wait for the PLL to turn on. */
 
 	/* Now take the PHY out of Reset again */
-	tmslow = ssb_read32(dev->dev, SSB_TMSLOW);
-	tmslow |= SSB_TMSLOW_FGC;
-	tmslow &= ~B43legacy_TMSLOW_PHYRESET;
-	ssb_write32(dev->dev, SSB_TMSLOW, tmslow);
-	ssb_read32(dev->dev, SSB_TMSLOW); /* flush */
+	ssb_core_ctl_flags(dev->dev, ~B43legacy_CORECTL_PHYRESET,
+			   SSB_CORECTL_FGC);
 	msleep(1);
-	tmslow &= ~SSB_TMSLOW_FGC;
-	ssb_write32(dev->dev, SSB_TMSLOW, tmslow);
-	ssb_read32(dev->dev, SSB_TMSLOW); /* flush */
+	ssb_core_ctl_flags(dev->dev, ~SSB_CORECTL_FGC, 0);
 	msleep(1);
 
 	/* Turn Analog ON */
@@ -720,7 +714,7 @@ void b43legacy_wireless_core_reset(struc
 
 	macctl = b43legacy_read32(dev, B43legacy_MMIO_MACCTL);
 	macctl &= ~B43legacy_MACCTL_GMODE;
-	if (flags & B43legacy_TMSLOW_GMODE) {
+	if (flags & B43legacy_CORECTL_GMODE) {
 		macctl |= B43legacy_MACCTL_GMODE;
 		dev->phy.gmode = true;
 	} else
@@ -2241,9 +2235,7 @@ static int b43legacy_chip_init(struct b4
 	b43legacy_write32(dev, B43legacy_MMIO_DMA4_IRQ_MASK, 0x0000DC00);
 	b43legacy_write32(dev, B43legacy_MMIO_DMA5_IRQ_MASK, 0x0000DC00);
 
-	value32 = ssb_read32(dev->dev, SSB_TMSLOW);
-	value32 |= B43legacy_TMSLOW_MACPHYCLKEN;
-	ssb_write32(dev->dev, SSB_TMSLOW, value32);
+	ssb_core_ctl_flags(dev->dev, ~0, B43legacy_CORECTL_MACPHYCLKEN);
 
 	b43legacy_write16(dev, B43legacy_MMIO_POWERUP_DELAY,
 			  dev->dev->bus->chipco.fast_pwrup_delay);
@@ -2567,19 +2559,12 @@ static int find_wldev_for_phymode(struct
 static void b43legacy_put_phy_into_reset(struct b43legacy_wldev *dev)
 {
 	struct ssb_device *sdev = dev->dev;
-	u32 tmslow;
 
-	tmslow = ssb_read32(sdev, SSB_TMSLOW);
-	tmslow &= ~B43legacy_TMSLOW_GMODE;
-	tmslow |= B43legacy_TMSLOW_PHYRESET;
-	tmslow |= SSB_TMSLOW_FGC;
-	ssb_write32(sdev, SSB_TMSLOW, tmslow);
+	ssb_core_ctl_flags(sdev, ~B43legacy_CORECTL_GMODE,
+			   B43legacy_CORECTL_PHYRESET | SSB_CORECTL_FGC);
 	msleep(1);
 
-	tmslow = ssb_read32(sdev, SSB_TMSLOW);
-	tmslow &= ~SSB_TMSLOW_FGC;
-	tmslow |= B43legacy_TMSLOW_PHYRESET;
-	ssb_write32(sdev, SSB_TMSLOW, tmslow);
+	ssb_core_ctl_flags(sdev, ~SSB_CORECTL_FGC, B43legacy_CORECTL_PHYRESET);
 	msleep(1);
 }
 
@@ -3271,7 +3256,7 @@ static int b43legacy_wireless_core_init(
 	if (err)
 		goto out;
 	if (!ssb_device_is_enabled(dev->dev)) {
-		tmp = phy->gmode ? B43legacy_TMSLOW_GMODE : 0;
+		tmp = phy->gmode ? B43legacy_CORECTL_GMODE : 0;
 		b43legacy_wireless_core_reset(dev, tmp);
 	}
 
@@ -3652,10 +3637,10 @@ static int b43legacy_wireless_core_attac
 	}
 	/* Get the PHY type. */
 	if (dev->dev->id.revision >= 5) {
-		u32 tmshigh;
+		u32 state;
 
-		tmshigh = ssb_read32(dev->dev, SSB_TMSHIGH);
-		have_gphy = !!(tmshigh & B43legacy_TMSHIGH_GPHY);
+		state = ssb_core_state_flags(dev->dev);
+		have_gphy = !!(state & B43legacy_CORESTAT_GPHY);
 		if (!have_gphy)
 			have_bphy = 1;
 	} else if (dev->dev->id.revision == 4)
@@ -3665,7 +3650,7 @@ static int b43legacy_wireless_core_attac
 
 	dev->phy.gmode = (have_gphy || have_bphy);
 	dev->phy.radio_on = true;
-	tmp = dev->phy.gmode ? B43legacy_TMSLOW_GMODE : 0;
+	tmp = dev->phy.gmode ? B43legacy_CORECTL_GMODE : 0;
 	b43legacy_wireless_core_reset(dev, tmp);
 
 	err = b43legacy_phy_versioning(dev);
@@ -3691,7 +3676,7 @@ static int b43legacy_wireless_core_attac
 		}
 	}
 	dev->phy.gmode = (have_gphy || have_bphy);
-	tmp = dev->phy.gmode ? B43legacy_TMSLOW_GMODE : 0;
+	tmp = dev->phy.gmode ? B43legacy_CORECTL_GMODE : 0;
 	b43legacy_wireless_core_reset(dev, tmp);
 
 	err = b43legacy_validate_chipaccess(dev);
--- linux-3.6.8.orig/drivers/net/wireless/b43legacy/phy.c	2012-11-26 22:15:45.000000000 +0200
+++ linux-3.6.8/drivers/net/wireless/b43legacy/phy.c	2012-12-08 02:54:34.500374389 +0200
@@ -148,7 +148,7 @@ void b43legacy_phy_calibrate(struct b43l
 	if (phy->type == B43legacy_PHYTYPE_G && phy->rev == 1) {
 		b43legacy_wireless_core_reset(dev, 0);
 		b43legacy_phy_initg(dev);
-		b43legacy_wireless_core_reset(dev, B43legacy_TMSLOW_GMODE);
+		b43legacy_wireless_core_reset(dev, B43legacy_CORECTL_GMODE);
 	}
 	phy->calibrated = 1;
 }
--- linux-3.6.8.orig/drivers/ssb/driver_gige.c	2012-12-08 02:52:49.506381568 +0200
+++ linux-3.6.8/drivers/ssb/driver_gige.c	2012-12-08 02:54:34.500374389 +0200
@@ -173,7 +173,7 @@ static int __devinit ssb_gige_probe(stru
 				    const struct ssb_device_id *id)
 {
 	struct ssb_gige *dev;
-	u32 base, tmslow, tmshigh;
+	u32 base, ctl, state;
 
 	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
 	if (!dev)
@@ -221,19 +221,17 @@ static int __devinit ssb_gige_probe(stru
 
 	/* Check if we have an RGMII or GMII PHY-bus.
 	 * On RGMII do not bypass the DLLs */
-	tmslow = ssb_read32(sdev, SSB_TMSLOW);
-	tmshigh = ssb_read32(sdev, SSB_TMSHIGH);
-	if (tmshigh & SSB_GIGE_TMSHIGH_RGMII) {
-		tmslow &= ~SSB_GIGE_TMSLOW_TXBYPASS;
-		tmslow &= ~SSB_GIGE_TMSLOW_RXBYPASS;
+	state = ssb_core_state_flags(sdev);
+	ctl = SSB_GIGE_CORECTL_DLLEN;
+	if (state & SSB_GIGE_CORESTAT_RGMII) {
 		dev->has_rgmii = 1;
 	} else {
-		tmslow |= SSB_GIGE_TMSLOW_TXBYPASS;
-		tmslow |= SSB_GIGE_TMSLOW_RXBYPASS;
+		ctl |= SSB_GIGE_CORECTL_TXBYPASS;
+		ctl |= SSB_GIGE_CORECTL_RXBYPASS;
 		dev->has_rgmii = 0;
 	}
-	tmslow |= SSB_GIGE_TMSLOW_DLLEN;
-	ssb_write32(sdev, SSB_TMSLOW, tmslow);
+	ssb_core_ctl_flags(sdev, ~(SSB_GIGE_CORECTL_TXBYPASS |
+				   SSB_GIGE_CORECTL_RXBYPASS), ctl);
 
 	ssb_set_drvdata(sdev, dev);
 	register_pci_controller(&dev->pci_controller);
--- linux-3.6.8.orig/drivers/ssb/main.c	2012-12-08 02:53:27.603378963 +0200
+++ linux-3.6.8/drivers/ssb/main.c	2012-12-08 02:54:34.501374389 +0200
@@ -1168,6 +1168,7 @@ static void ssb_device_enable_sb(struct 
 	u32 val;
 
 	ssb_device_disable(dev, core_specific_flags);
+	core_specific_flags <<= SSB_TMSLOW_FLAGS_SHIFT;
 	ssb_write32(dev, SSB_TMSLOW,
 		    SSB_TMSLOW_RESET | SSB_TMSLOW_CLOCK |
 		    SSB_TMSLOW_FGC | core_specific_flags);
@@ -1227,6 +1228,9 @@ static void ssb_device_disable_sb(struct
 	if (ssb_read32(dev, SSB_TMSLOW) & SSB_TMSLOW_RESET)
 		return;
 
+	SSB_WARN_ON(core_specific_flags & 0xFFFF0000);
+
+	core_specific_flags <<= SSB_TMSLOW_FLAGS_SHIFT;
 	reject = ssb_tmslow_reject_bitmask(dev);
 
 	if (ssb_read32(dev, SSB_TMSLOW) & SSB_TMSLOW_CLOCK) {
@@ -1281,7 +1285,7 @@ u32 ssb_dma_translation(struct ssb_devic
 		return 0;
 	case SSB_BUSTYPE_PCI:
 		if (pci_is_pcie(dev->bus->host_pci) &&
-		    ssb_read32(dev, SSB_TMSHIGH) & SSB_TMSHIGH_DMA64) {
+		    ssb_core_state_flags(dev) & SSB_CORESTAT_DMA64) {
 			return SSB_PCIE_DMA_H32;
 		} else {
 			if (ssb_dma_translation_special_bit(dev))
@@ -1437,14 +1441,19 @@ static u32 ssb_admatch_size_sb(struct ss
 static u32 ssb_core_ctl_flags_sb(struct ssb_device *dev, u32 mask, u32 val)
 {
 	u32 tmp;
+	mask = ~mask;
+
+	SSB_WARN_ON((mask | val) & 0xFFFF0000);
 
-	if (~mask || val) {
-		tmp = (ssb_read32(dev, SSB_TMSLOW) & mask) | val;
+	if (mask || val) {
+		tmp = (ssb_read32(dev, SSB_TMSLOW) &
+		       ~(mask << SSB_TMSLOW_FLAGS_SHIFT)) |
+		       (val << SSB_TMSLOW_FLAGS_SHIFT);
 		ssb_write32(dev, SSB_TMSLOW, tmp);
 	}
 
 	/* readback */
-	tmp = ssb_read32(dev, SSB_TMSLOW);
+	tmp = ssb_read32(dev, SSB_TMSLOW) >> SSB_TMSLOW_FLAGS_SHIFT;
 	udelay(1);
 
 	return tmp;
--- linux-3.6.8.orig/drivers/ssb/ssb_private.h	2012-12-08 02:32:27.000000000 +0200
+++ linux-3.6.8/drivers/ssb/ssb_private.h	2012-12-08 02:54:34.501374389 +0200
@@ -256,4 +256,26 @@ static inline int ssb_watchdog_register(
 }
 #endif /* CONFIG_SSB_EMBEDDED */
 
+/* SB-style bus core control and state registers */
+#define SSB_TMSLOW		0x0F98     /* SB Target State Low */
+#define  SSB_TMSLOW_RESET	0x00000001 /* Reset */
+#define  SSB_TMSLOW_REJECT	0x00000002 /* Reject (Standard Backplane) */
+#define  SSB_TMSLOW_REJECT_23	0x00000004 /* Reject (Backplane rev 2.3) */
+#define  SSB_TMSLOW_CLOCK	0x00010000 /* Clock Enable */
+#define  SSB_TMSLOW_FGC		0x00020000 /* Force Gated Clocks On */
+#define  SSB_TMSLOW_PE		0x40000000 /* Power Management Enable */
+#define  SSB_TMSLOW_BE		0x80000000 /* BIST Enable */
+#define  SSB_TMSLOW_FLAGS_SHIFT		16 /* Flags shift for TMSLOW
+					    * register of SB-style buses */
+#define SSB_TMSHIGH		0x0F9C     /* SB Target State High */
+#define  SSB_TMSHIGH_SERR	0x00000001 /* S-error */
+#define  SSB_TMSHIGH_INT	0x00000002 /* Interrupt */
+#define  SSB_TMSHIGH_BUSY	0x00000004 /* Busy */
+#define  SSB_TMSHIGH_TO		0x00000020 /* Timeout. Backplane rev >= 2.3 only */
+#define  SSB_TMSHIGH_DMA64	0x10000000 /* 64bit DMA supported */
+#define  SSB_TMSHIGH_GCR	0x20000000 /* Gated Clock Request */
+#define  SSB_TMSHIGH_BISTF	0x40000000 /* BIST Failed */
+#define  SSB_TMSHIGH_BISTD	0x80000000 /* BIST Done */
+#define  SSB_TMSHIGH_FLAGS_SHIFT	16 /* Flags shift for TMSHIGH
+					    * register of SB-style buses */
 #endif /* LINUX_SSB_PRIVATE_H_ */
--- linux-3.6.8.orig/drivers/usb/host/ssb-hcd.c	2012-12-08 02:52:49.507381568 +0200
+++ linux-3.6.8/drivers/usb/host/ssb-hcd.c	2012-12-08 02:54:34.501374389 +0200
@@ -30,7 +30,7 @@ MODULE_AUTHOR("Hauke Mehrtens");
 MODULE_DESCRIPTION("Common USB driver for SSB Bus");
 MODULE_LICENSE("GPL");
 
-#define SSB_HCD_TMSLOW_HOSTMODE	(1 << 29)
+#define SSB_OHCI_CORECTL_HOSTMODE	(1 << 13)
 
 struct ssb_hcd_device {
 	struct platform_device *ehci_dev;
@@ -86,7 +86,7 @@ static u32 __devinit ssb_hcd_init_chip(s
 
 	if (dev->id.coreid == SSB_DEV_USB11_HOSTDEV)
 		/* Put the device into host-mode. */
-		flags |= SSB_HCD_TMSLOW_HOSTMODE;
+		flags |= SSB_OHCI_CORECTL_HOSTMODE;
 
 	ssb_device_enable(dev, flags);
 
--- linux-3.6.8.orig/include/linux/ssb/ssb_driver_gige.h	2012-12-08 02:32:27.000000000 +0200
+++ linux-3.6.8/include/linux/ssb/ssb_driver_gige.h	2012-12-08 02:54:34.501374389 +0200
@@ -20,12 +20,12 @@
 #define SSB_GIGE_SHIM_MAOCPSI		0x0C10 /* PCI to OCP: MaocpSI Control (32bit) */
 #define SSB_GIGE_SHIM_SIOCPMA		0x0C14 /* PCI to OCP: SiocpMa Control (32bit) */
 
-/* TM Status High flags */
-#define SSB_GIGE_TMSHIGH_RGMII		0x00010000 /* Have an RGMII PHY-bus */
-/* TM Status Low flags */
-#define SSB_GIGE_TMSLOW_TXBYPASS	0x00080000 /* TX bypass (no delay) */
-#define SSB_GIGE_TMSLOW_RXBYPASS	0x00100000 /* RX bypass (no delay) */
-#define SSB_GIGE_TMSLOW_DLLEN		0x01000000 /* Enable DLL controls */
+/* Gige core control flags */
+#define SSB_GIGE_CORESTAT_RGMII		0x00010000 /* Have an RGMII PHY-bus */
+/* Gige core status flags */
+#define SSB_GIGE_CORECTL_TXBYPASS	0x00080000 /* TX bypass (no delay) */
+#define SSB_GIGE_CORECTL_RXBYPASS	0x00100000 /* RX bypass (no delay) */
+#define SSB_GIGE_CORECTL_DLLEN		0x01000000 /* Enable DLL controls */
 
 /* Boardflags (low) */
 #define SSB_GIGE_BFL_ROBOSWITCH		0x0010
--- linux-3.6.8.orig/include/linux/ssb/ssb.h	2012-12-08 02:53:27.603378963 +0200
+++ linux-3.6.8/include/linux/ssb/ssb.h	2012-12-08 02:54:34.502374389 +0200
@@ -558,14 +558,14 @@ static inline int ssb_device_is_enabled(
 {
 	return dev->ops->device_is_enabled(dev);
 }
-/* Enable a device and pass device-specific SSB_TMSLOW flags.
+/* Enable a device and pass device-specific SSB_CORECTL flags.
  * If no device-specific flags are available, use 0. */
 static inline void ssb_device_enable(struct ssb_device *dev,
 				     u32 core_specific_flags)
 {
 	return dev->ops->device_enable(dev, core_specific_flags);
 }
-/* Disable a device in hardware and pass SSB_TMSLOW flags (if any). */
+/* Disable a device in hardware and pass SSB_CORECTL flags (if any). */
 static inline void ssb_device_disable(struct ssb_device *dev,
 				      u32 core_specific_flags)
 {
--- linux-3.6.8.orig/include/linux/ssb/ssb_regs.h	2012-11-26 22:15:45.000000000 +0200
+++ linux-3.6.8/include/linux/ssb/ssb_regs.h	2012-12-08 02:54:34.502374389 +0200
@@ -58,6 +58,24 @@
 
 #define SSB_BAR0_MAX_RETRIES	50
 
+/* AI/SB independent core control and status flags for use with
+ * core_ctl_flags, core_state_flags, device_enable, device_disable
+ * ssb device helpers.
+ * Use instead of core-dependant SSB_TMSLO_xx and SSB_TMSHIGH_xx defines
+ */
+/* SSB SB TMSLOW/SSB AI IOCTL */
+#define SSB_CORECTL_CLOCK		0x0001 /* Clock Enable */
+#define SSB_CORECTL_FGC			0x0002 /* Force Gated Clocks On */
+#define SSB_CORECTL_PE			0x4000 /* Power Management Enable */
+#define SSB_CORECTL_BE			0x8000 /* BIST Enable */
+#define SSB_CORECTL_CORE_BITS		0x3FFC /* Core-specific flags mask */
+/* SSB SB TMSHIGH/SSB AI IOSTAT */
+#define SSB_CORESTAT_DMA64		0x1000 /* 64-bit DMA engine */
+#define SSB_CORESTAT_GCR		0x2000 /* Gated Clock Request */
+#define SSB_CORESTAT_BISTF		0x4000 /* BIST Failed */
+#define SSB_CORESTAT_BISTD		0x8000 /* BIST Done */
+#define SSB_CORESTAT_CORE_BITS		0x0FFF /* Core-specific flags mask */
+
 /* Silicon backplane configuration register definitions */
 #define SSB_IPSFLAG		0x0F08
 #define	 SSB_IPSFLAG_IRQ1	0x0000003F /* which sbflags get routed to mips interrupt 1 */
@@ -95,25 +113,10 @@
 #define  SSB_INTVEC_USB		0x00000010 /* Enable interrupts for usb */
 #define  SSB_INTVEC_EXTIF	0x00000020 /* Enable interrupts for external i/f */
 #define  SSB_INTVEC_ENET1	0x00000040 /* Enable interrupts for enet 1 */
-#define SSB_TMSLOW		0x0F98     /* SB Target State Low */
-#define  SSB_TMSLOW_RESET	0x00000001 /* Reset */
-#define  SSB_TMSLOW_REJECT	0x00000002 /* Reject (Standard Backplane) */
-#define  SSB_TMSLOW_REJECT_23	0x00000004 /* Reject (Backplane rev 2.3) */
-#define  SSB_TMSLOW_CLOCK	0x00010000 /* Clock Enable */
-#define  SSB_TMSLOW_FGC		0x00020000 /* Force Gated Clocks On */
-#define  SSB_TMSLOW_PE		0x40000000 /* Power Management Enable */
-#define  SSB_TMSLOW_BE		0x80000000 /* BIST Enable */
-#define SSB_TMSHIGH		0x0F9C     /* SB Target State High */
-#define  SSB_TMSHIGH_SERR	0x00000001 /* S-error */
-#define  SSB_TMSHIGH_INT	0x00000002 /* Interrupt */
-#define  SSB_TMSHIGH_BUSY	0x00000004 /* Busy */
-#define  SSB_TMSHIGH_TO		0x00000020 /* Timeout. Backplane rev >= 2.3 only */
-#define  SSB_TMSHIGH_COREFL	0x1FFF0000 /* Core specific flags */
-#define  SSB_TMSHIGH_COREFL_SHIFT	16
-#define  SSB_TMSHIGH_DMA64	0x10000000 /* 64bit DMA supported */
-#define  SSB_TMSHIGH_GCR	0x20000000 /* Gated Clock Request */
-#define  SSB_TMSHIGH_BISTF	0x40000000 /* BIST Failed */
-#define  SSB_TMSHIGH_BISTD	0x80000000 /* BIST Done */
+/*
+ * SSB_TMSLOW and SSB_TMSHIGH registers' definitions moved out to ssb_private.h
+ * use SSB_CORECTL, SSB_CORESTAT or own core-specific flags' defines instead.
+ */
 #define SSB_BWA0		0x0FA0
 #define SSB_IMCFGLO		0x0FA8
 #define  SSB_IMCFGLO_SERTO	0x00000007 /* Service timeout */
